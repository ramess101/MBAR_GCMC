#!/bin/bash
####

clean() {   # Make it so everything is killed on an interrupt
local pids=$(jobs -pr)
echo "On exit sending kill signal to: $pids"
[ -n "$pids" ] && kill $pids
exit 1
}
trap "clean" SIGINT SIGTERM EXIT SIGQUIT  # Call cleanup when asked to

Compound=C6H14
Compound_PDB=C6P
Model=Potoff
iState_low=0
iState_high=8
nproc=(2 2 2 2 2 2 2 1 1)
NSTAGES=100
NBASIS=6
pin0=0

#Specify the path location for files
scripts_path=~/GOMC_Scripts
conditions_path=~/GOMC_Conditions
PDB_PSF_path=~/GOMC_PDB_PSF  
input_path=~/"$Compound"/GOMC/GOMC_input
output_path=~/"$Compound"/GOMC/GCMC/"$Model" 

job_date=$(date "+%Y_%m_%d_%H_%M_%S")

jobfile="$output_path"/"$Compound"_job_"$job_date" 
cp "$scripts_path"/run_all_GCMC "$jobfile" #Keep track of what jobs have been submitted
cat "$scripts_path"/genBasisFunctions.sh >> "$jobfile"  # Inellegant append
#cat "$scripts_path"/run_single.sh >> "$jobfile"  # Another inellegant append
#touch "$output_path"/warnings_job_"$job_date"

### Read the temperature file into the array 'Temp'
if [ -f "$conditions_path"/"$Compound"_Temp ]
then

while read line
do
Temp+=("$line")
done < "$conditions_path"/"$Compound"_Temp

else
echo "$Compound"_Temp file does not exist
exit 0

fi

### Read the box_length file into the array 'Lbox'
if [ -f "$conditions_path"/"$Compound"_box_length ]
then

while read line
do
Lbox+=("$line")
done < "$conditions_path"/"$Compound"_box_length

else
echo "$Compound"_box_length file does not exist
exit 0

fi

### Read the ChemPot file into the array 'ChemPot'
if [ -f "$conditions_path"/"$Compound"_ChemPot ]
then

while read line
do
ChemPot+=("$line")
done < "$conditions_path"/"$Compound"_ChemPot

else
echo "$Compound"_ChemPot file does not exist
exit 0

fi

cd "$output_path" || error_report "Error switching to $output_path" "0" "0" "preprocessing"
pinoffset="$pin0"

for iState in $(seq $iState_low $iState_high)

do

cd "$output_path" || exit 0

mkdir "${Temp[iState]}"
cd "${Temp[iState]}"

cp "$scripts_path"/in_start_template.conf in_start.conf
cp "$scripts_path"/in_restart_template.conf in_restart.conf
cp "$scripts_path"/in_rerun_template.conf in_rerun.conf

sed -i -e s/some_Temp/"${Temp[iState]}"/ in_start.conf
sed -i -e s/some_Lbox/"${Lbox[iState]}"/ in_start.conf
sed -i -e s/some_ChemPot/"${ChemPot[iState]}"/ in_start.conf
sed -i -e s/some_Compound/"$Compound_PDB"/ in_start.conf

sed -i -e s/some_Temp/"${Temp[iState]}"/ in_restart.conf
sed -i -e s/some_Lbox/"${Lbox[iState]}"/ in_restart.conf
sed -i -e s/some_ChemPot/"${ChemPot[iState]}"/ in_restart.conf
sed -i -e s/some_Compound/"$Compound_PDB"/ in_restart.conf

sed -i -e s/some_Temp/"${Temp[iState]}"/ in_rerun.conf
sed -i -e s/some_Lbox/"${Lbox[iState]}"/ in_rerun.conf
sed -i -e s/some_ChemPot/"${ChemPot[iState]}"/ in_rerun.conf
sed -i -e s/some_Compound/"$Compound_PDB"/ in_rerun.conf

cp "$scripts_path"/genBasisFunctions.sh genBasisFunctions.sh
chmod u+x genBasisFunctions.sh

### Vapor phase runs just run on the same processor sequentially because they are at least twice as fast
if [ "${nproc[iState]}" -gt 1 ] 
then

echo "$iState" in background

./genBasisFunctions.sh "${nproc[iState]}" "$NSTAGES" "$NBASIS" "$scripts_path" &
taskset -cp "$pinoffset"-"$((pinoffset+nproc[iState]-1))" $! > /dev/null 2>&1

else

echo "$iState" not in background

./genBasisFunctions.sh "${nproc[iState]}" "$NSTAGES" "$NBASIS" "$scripts_path" &
taskset -cp "$pinoffset"-"$((pinoffset+nproc[iState]-1))" $! > /dev/null 2>&1

fi

pinoffset=$((pinoffset+nproc[iState]))

done

top


#### Wait for all jobs to finish

done=NO
count=0

while [ "$done" = "NO" ]
do
sleep 600s

count=$((count + 1))

if [ $count -gt 600 ]
then
echo "timed out"
done=YES
fi

if pgrep -a "GOMC_CPU_GCMC"
then
echo "not done"
else
echo "done"
done=YES
fi

done

killall -w GOMC_CPU_GCMC # In case timed out, kill the jobs

exit 0

#######